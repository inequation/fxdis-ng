/**************************************************************************
 *
 * Copyright 2010 Luca Barbieri
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "dxbc.h"
#include <iomanip>
#include <memory>
#include <string.h>
#include <d3d11shader.h>

static std::ostream& operator<<(std::ostream& out, const D3D11_SHADER_TYPE_DESC& type)
{
	out << dxbc_shader_type_names[type.Type];
	switch (type.Class)
	{
	case D3D_SVC_SCALAR:
		break;
	case D3D_SVC_VECTOR:
		out << type.Columns;
		break;
	case D3D_SVC_MATRIX_ROWS:
		out << type.Rows << "x" << type.Columns;
		break;
	case D3D_SVC_MATRIX_COLUMNS:
		out << type.Columns << "x" << type.Rows;
		break;
	default:
		assert(!"Unhandled shader variable class");
		break;
	}
	return out;
}

std::ostream& operator<<(std::ostream& out, dxbc_chunk_resource_definition& rdef)
{
	D3D11_SHADER_BUFFER_DESC* buffers = nullptr;
	D3D11_SHADER_TYPE_DESC* types = nullptr;
	D3D11_SHADER_VARIABLE_DESC* vars = nullptr;
	D3D11_SHADER_INPUT_BIND_DESC* bindings = nullptr;
	char* creator;
	int buffer_count, binding_count;
	dxbc_parse_resource_definition(&rdef, buffer_count, &buffers, binding_count, &bindings, &creator);
	out << "// Generated by " << creator << "\n"
		"//\n";

	if (buffer_count > 0)
	{
		out << "//\n"
			   "// Buffer Definitions:\n"
			   "//\n";
		for (int j = 0; j < buffer_count; ++j)
		{
			out << "// cbuffer cbuf" << j << "\n"
				"// {\n"
				"//\n";
			int vcount = dxbc_parse_shader_variables(&rdef, j, &types, &vars);
			for (int k = 0; k < vcount; ++k)
			{
				out << "//   ";
				auto before = out.tellp();
				out << types[k] << " " << vars[k].Name;
				if (types[k].Elements > 1)
				{
					out << "[" << types[k].Elements << "]";
				}
				out << ";";
				for (auto l = out.tellp() - before; l < 35; ++l)
				{
					out << " ";
				}
				out << "// Offset: " << std::setw(4) << std::right << vars[k].StartOffset <<
					   " Size: " << std::setw(5) << std::right << vars[k].Size <<
					   //" Flags: " << std::setw(6) << std::right << std::hex << vars[k].uFlags <<
					   std::setw(0) << std::dec << "\n";
			}
			out << "//\n"
				   "// }\n";

			free(vars);
			vars = nullptr;
		}
	}
	out << "//\n//\n";

	auto get_binding_format = [](std::ostream& out, D3D11_SHADER_INPUT_BIND_DESC& binding) -> std::ostream&
	{
		const char* bare = dxbc_shader_return_type_names[binding.ReturnType];
		if (binding.uFlags & D3D_SIF_TEXTURE_COMPONENTS)
		{
			char* s = new char[strlen(bare) + 2];
			strcpy(s, bare);
			strcat(s, "4");
			out << s;
			delete s;
		}
		else
		{
			out << bare;
		}
		return out;
	};

	auto get_binding_dimension = [](std::ostream& out, D3D11_SHADER_INPUT_BIND_DESC& binding) -> std::ostream&
	{
		const char* bare = dxbc_shader_dimension_names[binding.Dimension];
		if (binding.Dimension == D3D_SRV_DIMENSION_TEXTURE2DMS ||
			binding.Dimension == D3D_SRV_DIMENSION_TEXTURE2DMSARRAY)
		{
			assert(binding.NumSamples < 10);
			char* s = new char[strlen(bare) + 2];
			sprintf(s, "%s%d", bare, binding.NumSamples);
			out << s;
			delete s;
		}
		else
		{
			out << bare;
		}
		return out;
	};

	if (binding_count > 0)
	{
		out << "// Resource Bindings:\n"
			   "//\n"
			   "// Name                                 Type  Format         Dim      HLSL Bind  Count  Flags\n"
			   "// ------------------------------ ---------- ------- ----------- -------------- ------ ------\n";
		for (int j = 0; j < binding_count; ++j)
		{
			out << "// " << std::setw(30) << std::left << bindings[j].Name << " " <<
				std::setw(10) << std::right << dxbc_shader_input_type_names[bindings[j].Type] << " " <<
				std::setw(7) << std::right; get_binding_format(out, bindings[j]) << " " <<
				std::setw(11) << std::right; get_binding_dimension(out, bindings[j]) << " " <<
				std::setw(13) << std::right << dxbc_shader_input_type_file_short_names[bindings[j].Type] << bindings[j].BindPoint << " " <<
				std::setw(6) << std::right << bindings[j].BindCount << " " <<
				std::setw(6) << std::right << std::hex << bindings[j].uFlags <<
				std::setw(0) << std::left << std::dec << "\n";
		}
		out << "//\n";
	}

	free(buffers);
	free(bindings);
	return out;
}

std::ostream& operator<<(std::ostream& out, dxbc_chunk_signature& sig)
{
	D3D11_SIGNATURE_PARAMETER_DESC* params;
	int count = dxbc_parse_signature(&sig, &params);

	const bool is_output = sig.fourcc == FOURCC_OSGN;

	if (count > 0)
	{
		out << "//\n"
			   "// " << (is_output ? "Out" : "In") << "put signature:\n"
			   "//\n"
			   "// Name                 Index   Mask Register    SysValue  Format   Used\n"
			   "// -------------------- ----- ------ -------- ----------- ------- ------\n";
		for (int j = 0; j < count; ++j)
		{
			out << "// " << std::setw(20) << std::left << params[j].SemanticName << " " <<
				std::setw(5) << std::right << params[j].SemanticIndex << "   ";
			for (unsigned i = 0; i < 4; ++i)
			{
				out << (params[j].Mask & (1 << i) ? "xyzw"[i] : ' ');
			}
			out << " " << std::setw(8) << std::right << params[j].Register << " " <<
				   std::setw(11) << std::right << dxbc_names[(is_output ? D3D_NAME_TARGET : 0) + params[j].SystemValueType] << " " <<
				   std::setw(7) << std::right << dxbc_register_component_type_names[params[j].ComponentType] << "   ";
			for (unsigned i = 0; i < 4; ++i)
			{
				out << ((params[j].ReadWriteMask & (1 << i) ^ !!is_output) ? "xyzw"[i] : ' ');
			}
			out << "\n";
		}
		out << "//\n";
	}

	free(params);
	return out;
}

std::ostream& operator<<(std::ostream& out, const dxbc_chunk_statistics& stat)
{
	return out << "// Approximately " << bswap_le32(stat.instruction_count) << " instruction slots used\n";
}

std::ostream& operator<<(std::ostream& out, const dxbc_container& container)
{
	for (unsigned i = 0; i < container.chunks.size(); ++i)
	{
		struct dxbc_chunk_header* chunk = container.chunks[i];
		char fourcc_str[5];
		memcpy(fourcc_str, &chunk->fourcc, 4);
		fourcc_str[4] = 0;
		out << "// DXBC chunk " << std::setw(2) << i << ": " << fourcc_str
			<< " offset " << ((char*)chunk - (char*)container.data) << " size "
			<< bswap_le32(chunk->size) << "\n";
		switch (chunk->fourcc)
		{
		case FOURCC_RDEF:
			out << *static_cast<dxbc_chunk_resource_definition*>(chunk);
			break;
		case FOURCC_ISGN:
		case FOURCC_OSGN:
			out << *static_cast<dxbc_chunk_signature*>(chunk);
			break;
		case FOURCC_STAT:
			out << *static_cast<dxbc_chunk_statistics*>(chunk);
			break;
		}
	}
	return out;
}
